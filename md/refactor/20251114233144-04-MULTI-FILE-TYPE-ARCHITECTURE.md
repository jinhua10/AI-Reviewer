# AI-Reviewer å¤šæ–‡ä»¶ç±»å‹æ‰©å±•æ¶æ„è®¾è®¡ï¼ˆç¬¬4éƒ¨åˆ†ï¼‰

**ç”Ÿæˆæ—¶é—´**: 2025-11-14 23:31:44  
**åˆ†æäººå‘˜**: ä¸–ç•Œé¡¶çº§æ¶æ„å¸ˆ  
**æ–‡æ¡£ç±»å‹**: æ¶æ„è®¾è®¡æ–‡æ¡£

---

## ğŸ“‹ æ¦‚è¿°

æ ¹æ®é¡¹ç›®ç›®æ ‡ï¼š"è®¾è®¡AIå¼•æ“ï¼Œè®¡åˆ’åƒé»‘å®¢æ¾ä¸€æ ·æ‰©å±•å¹¶è¯»å–å„ç±»æ–‡ä»¶ç±»å‹ï¼ˆåª’ä½“ã€æ–‡æ¡£ç­‰ï¼‰ï¼ŒåæœŸæœŸæœ›åˆ©ç”¨å„ç±»AIæ¨¡å‹å¯¹å„ç±»æ–‡ä»¶è¿›è¡Œç”¨æˆ·æƒ³è¦åšçš„äº‹æƒ…ï¼Œä¾‹å¦‚æ•°æ®åˆ†æã€æ€»ç»“ç­‰è¡Œä¸º"ã€‚

æœ¬æŠ¥å‘Šè¯¦ç»†è®¾è®¡å¤šæ–‡ä»¶ç±»å‹æ”¯æŒçš„å®Œæ•´æ¶æ„æ–¹æ¡ˆã€‚

---

## ğŸ¯ å¤šæ–‡ä»¶ç±»å‹æ”¯æŒæ€»ä½“æ¶æ„

### æ¶æ„å…¨æ™¯å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         AI-Reviewer å¼•æ“                              â”‚
â”‚                   (Multi-Modal File Processing)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                         â”‚                         â”‚
         â–¼                         â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Input Adapters  â”‚      â”‚  Core Engine     â”‚      â”‚ Output Adapters â”‚
â”‚                 â”‚      â”‚                 â”‚      â”‚                 â”‚
â”‚ â€¢ File System   â”‚      â”‚ â€¢ Orchestrator   â”‚      â”‚ â€¢ Report Gen    â”‚
â”‚ â€¢ Git Repo      â”‚      â”‚ â€¢ Strategy Mgr   â”‚      â”‚ â€¢ Visualization â”‚
â”‚ â€¢ S3 Storage    â”‚      â”‚ â€¢ AI Service     â”‚      â”‚ â€¢ Export        â”‚
â”‚ â€¢ ZIP Archive   â”‚      â”‚ â€¢ Cache          â”‚      â”‚ â€¢ Notification  â”‚
â”‚ â€¢ URL Download  â”‚      â”‚ â€¢ Metrics        â”‚      â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                         â”‚                         â”‚
         â–¼                         â–¼                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Code Processor  â”‚      â”‚  Media Processor â”‚      â”‚  Doc Processor   â”‚
â”‚                 â”‚      â”‚                 â”‚      â”‚                 â”‚
â”‚ â€¢ Java Parser   â”‚      â”‚ â€¢ Image         â”‚      â”‚ â€¢ PDF           â”‚
â”‚ â€¢ Python Parser â”‚      â”‚ â€¢ Video         â”‚      â”‚ â€¢ Word/Excel    â”‚
â”‚ â€¢ JS/TS Parser  â”‚      â”‚ â€¢ Audio         â”‚      â”‚ â€¢ Markdown      â”‚
â”‚ â€¢ Go Parser     â”‚      â”‚ â€¢ 3D Model      â”‚      â”‚ â€¢ Text          â”‚
â”‚ â€¢ C++ Parser    â”‚      â”‚                 â”‚      â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                         â”‚                         â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚
                                   â–¼
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   AI Model Integration    â”‚
                    â”‚                          â”‚
                    â”‚ â€¢ Text Models (GPT, etc) â”‚
                    â”‚ â€¢ Vision Models          â”‚
                    â”‚ â€¢ Multi-Modal Models     â”‚
                    â”‚ â€¢ Custom Models          â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¨ æ ¸å¿ƒé¢†åŸŸæ¨¡å‹æ‰©å±•

### 1. å¢å¼ºçš„ SourceFile æ¨¡å‹

```java
package top.yumbo.ai.reviewer.domain.model;

import lombok.Builder;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.nio.file.Path;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * æºæ–‡ä»¶é¢†åŸŸæ¨¡å‹ï¼ˆå¢å¼ºç‰ˆï¼‰
 * æ”¯æŒå¤šç§æ–‡ä»¶ç±»å‹ï¼šä»£ç ã€å›¾ç‰‡ã€è§†é¢‘ã€æ–‡æ¡£ç­‰
 */
@Data
@Builder
@Slf4j
public class SourceFile {
    
    // åŸºç¡€ä¿¡æ¯
    private String fileName;
    private Path path;
    private Path relativePath;
    private long size;
    private LocalDateTime createdAt;
    private LocalDateTime modifiedAt;
    
    // æ–‡ä»¶åˆ†ç±»
    private FileCategory category;
    private FileType fileType;
    private String mimeType;
    private ProjectType projectType; // ä»…ä»£ç æ–‡ä»¶æœ‰æ•ˆ
    
    // å†…å®¹ä¿¡æ¯
    private String content;          // æ–‡æœ¬å†…å®¹ï¼ˆä»£ç ã€æ–‡æ¡£ï¼‰
    private byte[] binaryContent;    // äºŒè¿›åˆ¶å†…å®¹ï¼ˆå›¾ç‰‡ã€è§†é¢‘ï¼‰
    
    // å…ƒæ•°æ®
    private FileMetadata metadata;
    
    // åˆ†æç»“æœï¼ˆæŒ‰éœ€åŠ è½½ï¼‰
    private transient Object analysisResult; // å¤šæ€ï¼šCodeInsight, ImageAnalysis, etc.
    
    /**
     * æ–‡ä»¶ç±»åˆ«ï¼ˆä¸€çº§åˆ†ç±»ï¼‰
     */
    public enum FileCategory {
        CODE("ä»£ç æ–‡ä»¶", true),
        DOCUMENT("æ–‡æ¡£æ–‡ä»¶", true),
        IMAGE("å›¾ç‰‡æ–‡ä»¶", false),
        VIDEO("è§†é¢‘æ–‡ä»¶", false),
        AUDIO("éŸ³é¢‘æ–‡ä»¶", false),
        DATA("æ•°æ®æ–‡ä»¶", true),
        CONFIG("é…ç½®æ–‡ä»¶", true),
        ARCHIVE("å‹ç¼©æ–‡ä»¶", false),
        OTHER("å…¶ä»–æ–‡ä»¶", false);
        
        private final String displayName;
        private final boolean textBased;
        
        FileCategory(String displayName, boolean textBased) {
            this.displayName = displayName;
            this.textBased = textBased;
        }
        
        public boolean isTextBased() {
            return textBased;
        }
    }
    
    /**
     * æ–‡ä»¶ç±»å‹ï¼ˆäºŒçº§åˆ†ç±» - è¯¦ç»†ï¼‰
     */
    @lombok.Getter
    public enum FileType {
        // ä»£ç ç±»
        JAVA("java", FileCategory.CODE, "text/x-java"),
        PYTHON("python", FileCategory.CODE, "text/x-python"),
        JAVASCRIPT("javascript", FileCategory.CODE, "text/javascript"),
        TYPESCRIPT("typescript", FileCategory.CODE, "text/typescript"),
        GO("go", FileCategory.CODE, "text/x-go"),
        RUST("rust", FileCategory.CODE, "text/x-rust"),
        CPP("c++", FileCategory.CODE, "text/x-c++src"),
        C("c", FileCategory.CODE, "text/x-csrc"),
        CSHARP("c#", FileCategory.CODE, "text/x-csharp"),
        
        // æ–‡æ¡£ç±»
        PDF("pdf", FileCategory.DOCUMENT, "application/pdf"),
        WORD("word", FileCategory.DOCUMENT, "application/vnd.openxmlformats-officedocument.wordprocessingml.document"),
        EXCEL("excel", FileCategory.DOCUMENT, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"),
        POWERPOINT("powerpoint", FileCategory.DOCUMENT, "application/vnd.openxmlformats-officedocument.presentationml.presentation"),
        MARKDOWN("markdown", FileCategory.DOCUMENT, "text/markdown"),
        TEXT("text", FileCategory.DOCUMENT, "text/plain"),
        RTF("rtf", FileCategory.DOCUMENT, "application/rtf"),
        
        // å›¾ç‰‡ç±»
        JPEG("jpeg", FileCategory.IMAGE, "image/jpeg"),
        PNG("png", FileCategory.IMAGE, "image/png"),
        GIF("gif", FileCategory.IMAGE, "image/gif"),
        SVG("svg", FileCategory.IMAGE, "image/svg+xml"),
        WEBP("webp", FileCategory.IMAGE, "image/webp"),
        BMP("bmp", FileCategory.IMAGE, "image/bmp"),
        TIFF("tiff", FileCategory.IMAGE, "image/tiff"),
        
        // è§†é¢‘ç±»
        MP4("mp4", FileCategory.VIDEO, "video/mp4"),
        AVI("avi", FileCategory.VIDEO, "video/x-msvideo"),
        MOV("mov", FileCategory.VIDEO, "video/quicktime"),
        MKV("mkv", FileCategory.VIDEO, "video/x-matroska"),
        WEBM("webm", FileCategory.VIDEO, "video/webm"),
        FLV("flv", FileCategory.VIDEO, "video/x-flv"),
        
        // éŸ³é¢‘ç±»
        MP3("mp3", FileCategory.AUDIO, "audio/mpeg"),
        WAV("wav", FileCategory.AUDIO, "audio/wav"),
        FLAC("flac", FileCategory.AUDIO, "audio/flac"),
        OGG("ogg", FileCategory.AUDIO, "audio/ogg"),
        M4A("m4a", FileCategory.AUDIO, "audio/mp4"),
        
        // æ•°æ®ç±»
        JSON("json", FileCategory.DATA, "application/json"),
        XML("xml", FileCategory.DATA, "application/xml"),
        CSV("csv", FileCategory.DATA, "text/csv"),
        YAML("yaml", FileCategory.DATA, "application/x-yaml"),
        SQL("sql", FileCategory.DATA, "application/sql"),
        
        // é…ç½®ç±»
        PROPERTIES("properties", FileCategory.CONFIG, "text/x-java-properties"),
        INI("ini", FileCategory.CONFIG, "text/plain"),
        TOML("toml", FileCategory.CONFIG, "application/toml"),
        ENV("env", FileCategory.CONFIG, "text/plain"),
        
        // å‹ç¼©ç±»
        ZIP("zip", FileCategory.ARCHIVE, "application/zip"),
        TAR("tar", FileCategory.ARCHIVE, "application/x-tar"),
        GZ("gzip", FileCategory.ARCHIVE, "application/gzip"),
        RAR("rar", FileCategory.ARCHIVE, "application/vnd.rar"),
        SEVEN_Z("7z", FileCategory.ARCHIVE, "application/x-7z-compressed"),
        
        // å…¶ä»–
        UNKNOWN("unknown", FileCategory.OTHER, "application/octet-stream");
        
        private final String name;
        private final FileCategory category;
        private final String mimeType;
        
        FileType(String name, FileCategory category, String mimeType) {
            this.name = name;
            this.category = category;
            this.mimeType = mimeType;
        }
        
        public static FileType fromExtension(String extension) {
            String ext = extension.toLowerCase().replaceFirst("^\\.", "");
            
            return switch (ext) {
                // ä»£ç 
                case "java" -> JAVA;
                case "py" -> PYTHON;
                case "js", "jsx", "mjs" -> JAVASCRIPT;
                case "ts", "tsx" -> TYPESCRIPT;
                case "go" -> GO;
                case "rs" -> RUST;
                case "cpp", "cc", "cxx", "c++" -> CPP;
                case "c" -> C;
                case "cs" -> CSHARP;
                
                // æ–‡æ¡£
                case "pdf" -> PDF;
                case "doc", "docx" -> WORD;
                case "xls", "xlsx" -> EXCEL;
                case "ppt", "pptx" -> POWERPOINT;
                case "md", "markdown" -> MARKDOWN;
                case "txt" -> TEXT;
                case "rtf" -> RTF;
                
                // å›¾ç‰‡
                case "jpg", "jpeg" -> JPEG;
                case "png" -> PNG;
                case "gif" -> GIF;
                case "svg" -> SVG;
                case "webp" -> WEBP;
                case "bmp" -> BMP;
                case "tif", "tiff" -> TIFF;
                
                // è§†é¢‘
                case "mp4" -> MP4;
                case "avi" -> AVI;
                case "mov" -> MOV;
                case "mkv" -> MKV;
                case "webm" -> WEBM;
                case "flv" -> FLV;
                
                // éŸ³é¢‘
                case "mp3" -> MP3;
                case "wav" -> WAV;
                case "flac" -> FLAC;
                case "ogg" -> OGG;
                case "m4a" -> M4A;
                
                // æ•°æ®
                case "json" -> JSON;
                case "xml" -> XML;
                case "csv" -> CSV;
                case "yaml", "yml" -> YAML;
                case "sql" -> SQL;
                
                // é…ç½®
                case "properties" -> PROPERTIES;
                case "ini" -> INI;
                case "toml" -> TOML;
                case "env" -> ENV;
                
                // å‹ç¼©
                case "zip" -> ZIP;
                case "tar" -> TAR;
                case "gz", "gzip" -> GZ;
                case "rar" -> RAR;
                case "7z" -> SEVEN_Z;
                
                default -> UNKNOWN;
            };
        }
    }
    
    /**
     * æ–‡ä»¶å…ƒæ•°æ®ï¼ˆå¯æ‰©å±•ï¼‰
     */
    @Data
    @Builder
    public static class FileMetadata {
        // é€šç”¨å…ƒæ•°æ®
        private String encoding;
        private Integer lineCount;
        private String checksum;
        
        // ä»£ç æ–‡ä»¶å…ƒæ•°æ®
        private Integer codeLines;
        private Integer commentLines;
        private Integer blankLines;
        private Double complexity;
        
        // å›¾ç‰‡å…ƒæ•°æ®
        private ImageMetadata imageMetadata;
        
        // è§†é¢‘å…ƒæ•°æ®
        private VideoMetadata videoMetadata;
        
        // æ–‡æ¡£å…ƒæ•°æ®
        private DocumentMetadata documentMetadata;
        
        // è‡ªå®šä¹‰å…ƒæ•°æ®
        private Map<String, Object> customMetadata;
    }
    
    /**
     * å›¾ç‰‡å…ƒæ•°æ®
     */
    @Data
    @Builder
    public static class ImageMetadata {
        private Integer width;
        private Integer height;
        private String format;
        private Integer bitDepth;
        private String colorSpace;
        private Boolean hasAlpha;
        private Long fileSize;
        private Double aspectRatio;
        private String cameraMake;
        private String cameraModel;
        private LocalDateTime captureTime;
        private String gpsLocation;
    }
    
    /**
     * è§†é¢‘å…ƒæ•°æ®
     */
    @Data
    @Builder
    public static class VideoMetadata {
        private Integer width;
        private Integer height;
        private Double duration;        // ç§’
        private Integer frameRate;      // FPS
        private Long bitrate;           // bps
        private String codec;
        private String audioCodec;
        private Integer audioChannels;
        private Integer audioSampleRate;
        private Long fileSize;
    }
    
    /**
     * æ–‡æ¡£å…ƒæ•°æ®
     */
    @Data
    @Builder
    public static class DocumentMetadata {
        private String title;
        private String author;
        private String subject;
        private String keywords;
        private LocalDateTime createdDate;
        private LocalDateTime modifiedDate;
        private Integer pageCount;
        private Integer wordCount;
        private Integer characterCount;
        private String language;
        private String application;  // åˆ›å»ºåº”ç”¨
    }
    
    // ä¾¿æ·æ–¹æ³•
    
    public boolean isCode() {
        return category == FileCategory.CODE;
    }
    
    public boolean isImage() {
        return category == FileCategory.IMAGE;
    }
    
    public boolean isVideo() {
        return category == FileCategory.VIDEO;
    }
    
    public boolean isDocument() {
        return category == FileCategory.DOCUMENT;
    }
    
    public boolean isTextBased() {
        return category != null && category.isTextBased();
    }
    
    public boolean isBinary() {
        return !isTextBased();
    }
    
    /**
     * è‡ªåŠ¨æ£€æµ‹æ–‡ä»¶ç±»å‹
     */
    public static FileType detectFileType(Path filePath) {
        String fileName = filePath.getFileName().toString();
        int dotIndex = fileName.lastIndexOf('.');
        
        if (dotIndex > 0 && dotIndex < fileName.length() - 1) {
            String extension = fileName.substring(dotIndex + 1);
            return FileType.fromExtension(extension);
        }
        
        return FileType.UNKNOWN;
    }
}
```

---

## ğŸ–¼ï¸ å›¾ç‰‡å¤„ç†æ¨¡å—è®¾è®¡

### ImageProcessingStrategy å®ç°

```java
package top.yumbo.ai.reviewer.adapter.input.media;

import lombok.Builder;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import top.yumbo.ai.reviewer.domain.model.SourceFile;
import top.yumbo.ai.reviewer.application.service.FileProcessingStrategy;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.stream.ImageInputStream;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;

/**
 * å›¾ç‰‡æ–‡ä»¶å¤„ç†ç­–ç•¥
 */
@Slf4j
public class ImageProcessingStrategy implements FileProcessingStrategy {
    
    private final AIService aiService;
    private final ImageQualityConfig config;
    
    @Override
    public boolean supports(SourceFile file) {
        return file.getCategory() == SourceFile.FileCategory.IMAGE;
    }
    
    @Override
    public ProcessingResult process(SourceFile file) {
        log.info("å¤„ç†å›¾ç‰‡æ–‡ä»¶: {}", file.getFileName());
        
        try {
            // 1. æå–åŸºç¡€å…ƒæ•°æ®
            ImageMetadata metadata = extractMetadata(file);
            
            // 2. è´¨é‡è¯„ä¼°
            ImageQuality quality = assessQuality(file, metadata);
            
            // 3. AI å›¾ç‰‡ç†è§£ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            ImageUnderstanding understanding = null;
            if (aiService.supportsVision()) {
                understanding = analyzeWithAI(file, metadata);
            }
            
            // 4. ç”Ÿæˆå¤„ç†ç»“æœ
            return ProcessingResult.builder()
                .file(file)
                .metadata(metadata)
                .quality(quality)
                .understanding(understanding)
                .success(true)
                .build();
                
        } catch (Exception e) {
            log.error("å›¾ç‰‡å¤„ç†å¤±è´¥: {}", file.getFileName(), e);
            return ProcessingResult.failure(file, e.getMessage());
        }
    }
    
    /**
     * æå–å›¾ç‰‡å…ƒæ•°æ®
     */
    private ImageMetadata extractMetadata(SourceFile file) throws IOException {
        Path path = file.getPath();
        
        try (ImageInputStream iis = ImageIO.createImageInputStream(Files.newInputStream(path))) {
            Iterator<ImageReader> readers = ImageIO.getImageReaders(iis);
            
            if (!readers.hasNext()) {
                throw new IOException("æ— æ³•è¯»å–å›¾ç‰‡: " + file.getFileName());
            }
            
            ImageReader reader = readers.next();
            reader.setInput(iis);
            
            // åŸºç¡€ä¿¡æ¯
            int width = reader.getWidth(0);
            int height = reader.getHeight(0);
            String format = reader.getFormatName();
            
            // EXIF ä¿¡æ¯ï¼ˆJPEGï¼‰
            IIOMetadata imageMetadata = reader.getImageMetadata(0);
            Map<String, String> exifData = extractExifData(imageMetadata);
            
            // è¯»å–å›¾ç‰‡
            BufferedImage image = reader.read(0);
            
            return ImageMetadata.builder()
                .width(width)
                .height(height)
                .format(format)
                .aspectRatio((double) width / height)
                .colorDepth(image.getColorModel().getPixelSize())
                .hasAlpha(image.getColorModel().hasAlpha())
                .fileSize(Files.size(path))
                .exifData(exifData)
                .build();
                
        }
    }
    
    /**
     * å›¾ç‰‡è´¨é‡è¯„ä¼°
     */
    private ImageQuality assessQuality(SourceFile file, ImageMetadata metadata) {
        ImageQuality.ImageQualityBuilder builder = ImageQuality.builder();
        
        int score = 100;
        List<String> issues = new ArrayList<>();
        
        // 1. åˆ†è¾¨ç‡æ£€æŸ¥
        if (metadata.getWidth() < config.getMinWidth() || 
            metadata.getHeight() < config.getMinHeight()) {
            score -= 20;
            issues.add(String.format("åˆ†è¾¨ç‡è¿‡ä½ (%dx%d)", metadata.getWidth(), metadata.getHeight()));
        }
        
        if (metadata.getWidth() > config.getMaxWidth() || 
            metadata.getHeight() > config.getMaxHeight()) {
            score -= 10;
            issues.add(String.format("åˆ†è¾¨ç‡è¿‡é«˜ (%dx%d)", metadata.getWidth(), metadata.getHeight()));
        }
        
        // 2. æ–‡ä»¶å¤§å°æ£€æŸ¥
        long sizeMB = metadata.getFileSize() / 1024 / 1024;
        if (sizeMB > config.getMaxSizeMB()) {
            score -= 15;
            issues.add(String.format("æ–‡ä»¶è¿‡å¤§ (%dMB)", sizeMB));
        }
        
        // 3. æ ¼å¼æ£€æŸ¥
        if (!config.getSupportedFormats().contains(metadata.getFormat().toLowerCase())) {
            score -= 10;
            issues.add("ä¸æ¨èçš„å›¾ç‰‡æ ¼å¼: " + metadata.getFormat());
        }
        
        // 4. å®½é«˜æ¯”æ£€æŸ¥
        double ratio = metadata.getAspectRatio();
        if (ratio < 0.5 || ratio > 2.0) {
            score -= 5;
            issues.add(String.format("å¼‚å¸¸çš„å®½é«˜æ¯”: %.2f", ratio));
        }
        
        // è®¡ç®—ç­‰çº§
        String grade = calculateGrade(score);
        
        return builder
            .score(score)
            .grade(grade)
            .issues(issues)
            .isValid(score >= config.getMinAcceptableScore())
            .build();
    }
    
    /**
     * AI å›¾ç‰‡ç†è§£
     */
    private ImageUnderstanding analyzeWithAI(SourceFile file, ImageMetadata metadata) {
        log.info("ä½¿ç”¨ AI åˆ†æå›¾ç‰‡: {}", file.getFileName());
        
        try {
            // æ„å»ºæç¤ºè¯
            String prompt = buildImageAnalysisPrompt(file, metadata);
            
            // è°ƒç”¨ AI æœåŠ¡ï¼ˆVision APIï¼‰
            String analysis = aiService.analyzeImage(file.getPath(), prompt);
            
            // è§£æ AI å“åº”
            return parseAIResponse(analysis);
            
        } catch (Exception e) {
            log.warn("AI å›¾ç‰‡åˆ†æå¤±è´¥: {}", file.getFileName(), e);
            return ImageUnderstanding.empty();
        }
    }
    
    /**
     * æ„å»ºå›¾ç‰‡åˆ†ææç¤ºè¯
     */
    private String buildImageAnalysisPrompt(SourceFile file, ImageMetadata metadata) {
        return String.format("""
            è¯·åˆ†æè¿™å¼ å›¾ç‰‡å¹¶æä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š
            
            1. **å†…å®¹æè¿°**: å›¾ç‰‡ä¸­åŒ…å«ä»€ä¹ˆå†…å®¹ï¼Ÿ
            2. **ä¸»é¢˜**: å›¾ç‰‡çš„ä¸»è¦ä¸»é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ
            3. **è´¨é‡è¯„ä¼°**: å›¾ç‰‡çš„æ¸…æ™°åº¦ã€æ„å›¾ã€è‰²å½©å¦‚ä½•ï¼Ÿ
            4. **ç”¨é€”å»ºè®®**: è¿™å¼ å›¾ç‰‡é€‚åˆç”¨äºä»€ä¹ˆåœºæ™¯ï¼Ÿ
            5. **æ”¹è¿›å»ºè®®**: å¦‚ä½•æ”¹è¿›è¿™å¼ å›¾ç‰‡ï¼Ÿ
            
            å›¾ç‰‡ä¿¡æ¯:
            - æ–‡ä»¶å: %s
            - åˆ†è¾¨ç‡: %dx%d
            - æ ¼å¼: %s
            - å¤§å°: %.2f MB
            
            è¯·ä»¥ JSON æ ¼å¼è¿”å›åˆ†æç»“æœã€‚
            """,
            file.getFileName(),
            metadata.getWidth(),
            metadata.getHeight(),
            metadata.getFormat(),
            metadata.getFileSize() / 1024.0 / 1024.0
        );
    }
    
    private String calculateGrade(int score) {
        if (score >= 90) return "A+";
        if (score >= 80) return "A";
        if (score >= 70) return "B";
        if (score >= 60) return "C";
        return "D";
    }
    
    @Data
    @Builder
    public static class ImageMetadata {
        private Integer width;
        private Integer height;
        private String format;
        private Double aspectRatio;
        private Integer colorDepth;
        private Boolean hasAlpha;
        private Long fileSize;
        private Map<String, String> exifData;
    }
    
    @Data
    @Builder
    public static class ImageQuality {
        private Integer score;
        private String grade;
        private Boolean isValid;
        private List<String> issues;
        private Map<String, Object> details;
    }
    
    @Data
    @Builder
    public static class ImageUnderstanding {
        private String description;
        private String theme;
        private List<String> objects;      // æ£€æµ‹åˆ°çš„å¯¹è±¡
        private List<String> colors;       // ä¸»è¦é¢œè‰²
        private String qualityAssessment;
        private String usageSuggestion;
        private List<String> improvements;
        private Double confidenceScore;
        
        public static ImageUnderstanding empty() {
            return ImageUnderstanding.builder()
                .description("N/A")
                .confidenceScore(0.0)
                .build();
        }
    }
    
    @Data
    @Builder
    public static class ImageQualityConfig {
        @Builder.Default
        private Integer minWidth = 800;
        
        @Builder.Default
        private Integer minHeight = 600;
        
        @Builder.Default
        private Integer maxWidth = 4096;
        
        @Builder.Default
        private Integer maxHeight = 4096;
        
        @Builder.Default
        private Integer maxSizeMB = 10;
        
        @Builder.Default
        private Integer minAcceptableScore = 60;
        
        @Builder.Default
        private Set<String> supportedFormats = Set.of("jpg", "jpeg", "png", "gif", "webp");
    }
}
```

---

## ğŸ“¹ è§†é¢‘å¤„ç†æ¨¡å—è®¾è®¡

### VideoProcessingStrategy å®ç°

```java
package top.yumbo.ai.reviewer.adapter.input.media;

import lombok.Builder;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import top.yumbo.ai.reviewer.domain.model.SourceFile;
import top.yumbo.ai.reviewer.application.service.FileProcessingStrategy;

import org.bytedeco.javacv.FFmpegFrameGrabber;
import org.bytedeco.javacv.Frame;
import org.bytedeco.javacv.Java2DFrameConverter;

import java.awt.image.BufferedImage;
import java.nio.file.Path;
import java.util.*;

/**
 * è§†é¢‘æ–‡ä»¶å¤„ç†ç­–ç•¥
 * ä½¿ç”¨ JavaCV (FFmpeg) è¿›è¡Œè§†é¢‘å¤„ç†
 */
@Slf4j
public class VideoProcessingStrategy implements FileProcessingStrategy {
    
    private final AIService aiService;
    private final VideoQualityConfig config;
    
    @Override
    public boolean supports(SourceFile file) {
        return file.getCategory() == SourceFile.FileCategory.VIDEO;
    }
    
    @Override
    public ProcessingResult process(SourceFile file) {
        log.info("å¤„ç†è§†é¢‘æ–‡ä»¶: {}", file.getFileName());
        
        try {
            // 1. æå–å…ƒæ•°æ®
            VideoMetadata metadata = extractMetadata(file);
            
            // 2. æå–å…³é”®å¸§
            List<VideoFrame> keyFrames = extractKeyFrames(file, metadata);
            
            // 3. è´¨é‡è¯„ä¼°
            VideoQuality quality = assessQuality(metadata, keyFrames);
            
            // 4. AI è§†é¢‘ç†è§£ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            VideoUnderstanding understanding = null;
            if (aiService.supportsVideo()) {
                understanding = analyzeWithAI(file, metadata, keyFrames);
            }
            
            return ProcessingResult.builder()
                .file(file)
                .metadata(metadata)
                .keyFrames(keyFrames)
                .quality(quality)
                .understanding(understanding)
                .success(true)
                .build();
                
        } catch (Exception e) {
            log.error("è§†é¢‘å¤„ç†å¤±è´¥: {}", file.getFileName(), e);
            return ProcessingResult.failure(file, e.getMessage());
        }
    }
    
    /**
     * æå–è§†é¢‘å…ƒæ•°æ®
     */
    private VideoMetadata extractMetadata(SourceFile file) throws Exception {
        Path path = file.getPath();
        
        try (FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(path.toFile())) {
            grabber.start();
            
            return VideoMetadata.builder()
                .width(grabber.getImageWidth())
                .height(grabber.getImageHeight())
                .duration(grabber.getLengthInTime() / 1000000.0) // å¾®ç§’è½¬ç§’
                .frameRate(grabber.getFrameRate())
                .bitrate(grabber.getVideoBitrate())
                .videoCodec(grabber.getVideoCodecName())
                .audioCodec(grabber.getAudioCodecName())
                .audioChannels(grabber.getAudioChannels())
                .format(grabber.getFormat())
                .totalFrames(grabber.getLengthInFrames())
                .build();
        }
    }
    
    /**
     * æå–å…³é”®å¸§
     */
    private List<VideoFrame> extractKeyFrames(SourceFile file, VideoMetadata metadata) throws Exception {
        Path path = file.getPath();
        List<VideoFrame> keyFrames = new ArrayList<>();
        
        int numFrames = config.getKeyFrameCount();
        double duration = metadata.getDuration();
        double interval = duration / (numFrames + 1);
        
        try (FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(path.toFile())) {
            grabber.start();
            
            Java2DFrameConverter converter = new Java2DFrameConverter();
            
            for (int i = 1; i <= numFrames; i++) {
                double timestamp = interval * i;
                long timestampMicros = (long) (timestamp * 1000000);
                
                grabber.setTimestamp(timestampMicros);
                Frame frame = grabber.grabImage();
                
                if (frame != null) {
                    BufferedImage image = converter.convert(frame);
                    
                    keyFrames.add(VideoFrame.builder()
                        .frameNumber(grabber.getFrameNumber())
                        .timestamp(timestamp)
                        .image(image)
                        .build());
                }
            }
            
            converter.close();
        }
        
        log.info("æå–äº† {} ä¸ªå…³é”®å¸§", keyFrames.size());
        return keyFrames;
    }
    
    /**
     * è§†é¢‘è´¨é‡è¯„ä¼°
     */
    private VideoQuality assessQuality(VideoMetadata metadata, List<VideoFrame> keyFrames) {
        int score = 100;
        List<String> issues = new ArrayList<>();
        
        // 1. åˆ†è¾¨ç‡æ£€æŸ¥
        if (metadata.getWidth() < config.getMinWidth() || 
            metadata.getHeight() < config.getMinHeight()) {
            score -= 20;
            issues.add(String.format("åˆ†è¾¨ç‡è¿‡ä½ (%dx%d)", metadata.getWidth(), metadata.getHeight()));
        }
        
        // 2. æ—¶é•¿æ£€æŸ¥
        if (metadata.getDuration() < config.getMinDuration()) {
            score -= 15;
            issues.add(String.format("è§†é¢‘è¿‡çŸ­ (%.1fç§’)", metadata.getDuration()));
        }
        
        if (metadata.getDuration() > config.getMaxDuration()) {
            score -= 10;
            issues.add(String.format("è§†é¢‘è¿‡é•¿ (%.1fç§’)", metadata.getDuration()));
        }
        
        // 3. å¸§ç‡æ£€æŸ¥
        if (metadata.getFrameRate() < config.getMinFrameRate()) {
            score -= 10;
            issues.add(String.format("å¸§ç‡è¿‡ä½ (%.1f fps)", metadata.getFrameRate()));
        }
        
        // 4. ç¼–ç æ ¼å¼æ£€æŸ¥
        if (!config.getSupportedCodecs().contains(metadata.getVideoCodec())) {
            score -= 5;
            issues.add("ä¸æ¨èçš„ç¼–ç æ ¼å¼: " + metadata.getVideoCodec());
        }
        
        String grade = calculateGrade(score);
        
        return VideoQuality.builder()
            .score(score)
            .grade(grade)
            .issues(issues)
            .isValid(score >= config.getMinAcceptableScore())
            .build();
    }
    
    /**
     * AI è§†é¢‘ç†è§£
     */
    private VideoUnderstanding analyzeWithAI(SourceFile file, VideoMetadata metadata, List<VideoFrame> keyFrames) {
        log.info("ä½¿ç”¨ AI åˆ†æè§†é¢‘: {}", file.getFileName());
        
        try {
            String prompt = buildVideoAnalysisPrompt(file, metadata);
            
            // åˆ†æå…³é”®å¸§
            List<String> frameAnalyses = new ArrayList<>();
            for (VideoFrame frame : keyFrames) {
                String frameAnalysis = aiService.analyzeImage(frame.getImage(), 
                    "æè¿°è¿™ä¸€å¸§çš„å†…å®¹ï¼ˆæ—¶é—´: " + String.format("%.1f", frame.getTimestamp()) + "ç§’ï¼‰");
                frameAnalyses.add(frameAnalysis);
            }
            
            // ç»¼åˆåˆ†æ
            String overallAnalysis = aiService.analyzeText(prompt + "\n\nå…³é”®å¸§åˆ†æ:\n" + 
                String.join("\n", frameAnalyses));
            
            return parseVideoAnalysis(overallAnalysis);
            
        } catch (Exception e) {
            log.warn("AI è§†é¢‘åˆ†æå¤±è´¥: {}", file.getFileName(), e);
            return VideoUnderstanding.empty();
        }
    }
    
    private String buildVideoAnalysisPrompt(SourceFile file, VideoMetadata metadata) {
        return String.format("""
            è¯·åˆ†æè¿™ä¸ªè§†é¢‘å¹¶æä¾›ä»¥ä¸‹ä¿¡æ¯ï¼š
            
            1. **å†…å®¹æ‘˜è¦**: è§†é¢‘çš„ä¸»è¦å†…å®¹æ˜¯ä»€ä¹ˆï¼Ÿ
            2. **åœºæ™¯åˆ†æ**: è§†é¢‘åŒ…å«å“ªäº›åœºæ™¯ï¼Ÿ
            3. **è´¨é‡è¯„ä¼°**: è§†é¢‘çš„ç”»è´¨ã€æµç•…åº¦å¦‚ä½•ï¼Ÿ
            4. **éŸ³é¢‘è¯„ä¼°**: éŸ³é¢‘è´¨é‡å¦‚ä½•ï¼Ÿ
            5. **ç”¨é€”å»ºè®®**: è¿™ä¸ªè§†é¢‘é€‚åˆç”¨äºä»€ä¹ˆåœºæ™¯ï¼Ÿ
            6. **æ”¹è¿›å»ºè®®**: å¦‚ä½•æ”¹è¿›è¿™ä¸ªè§†é¢‘ï¼Ÿ
            
            è§†é¢‘ä¿¡æ¯:
            - æ–‡ä»¶å: %s
            - åˆ†è¾¨ç‡: %dx%d
            - æ—¶é•¿: %.1f ç§’
            - å¸§ç‡: %.1f fps
            - ç¼–ç : %s
            
            è¯·ä»¥ JSON æ ¼å¼è¿”å›åˆ†æç»“æœã€‚
            """,
            file.getFileName(),
            metadata.getWidth(),
            metadata.getHeight(),
            metadata.getDuration(),
            metadata.getFrameRate(),
            metadata.getVideoCodec()
        );
    }
    
    @Data
    @Builder
    public static class VideoMetadata {
        private Integer width;
        private Integer height;
        private Double duration;
        private Double frameRate;
        private Long bitrate;
        private String videoCodec;
        private String audioCodec;
        private Integer audioChannels;
        private String format;
        private Integer totalFrames;
    }
    
    @Data
    @Builder
    public static class VideoFrame {
        private Integer frameNumber;
        private Double timestamp;
        private BufferedImage image;
    }
    
    @Data
    @Builder
    public static class VideoQuality {
        private Integer score;
        private String grade;
        private Boolean isValid;
        private List<String> issues;
    }
    
    @Data
    @Builder
    public static class VideoUnderstanding {
        private String summary;
        private List<String> scenes;
        private String videoQuality;
        private String audioQuality;
        private String usageSuggestion;
        private List<String> improvements;
        
        public static VideoUnderstanding empty() {
            return VideoUnderstanding.builder()
                .summary("N/A")
                .build();
        }
    }
    
    @Data
    @Builder
    public static class VideoQualityConfig {
        @Builder.Default
        private Integer minWidth = 720;
        
        @Builder.Default
        private Integer minHeight = 480;
        
        @Builder.Default
        private Double minDuration = 10.0;
        
        @Builder.Default
        private Double maxDuration = 600.0;
        
        @Builder.Default
        private Double minFrameRate = 24.0;
        
        @Builder.Default
        private Integer minAcceptableScore = 60;
        
        @Builder.Default
        private Integer keyFrameCount = 10;
        
        @Builder.Default
        private Set<String> supportedCodecs = Set.of("h264", "h265", "vp8", "vp9");
    }
}
```

---

**æŠ¥å‘Šç»“æŸ - ç¬¬4éƒ¨åˆ†**

ç»§ç»­é˜…è¯»ï¼š
- ã€Šç¬¬5éƒ¨åˆ†ï¼šæ–‡æ¡£å¤„ç†ä¸ AI å¼•æ“æœªæ¥æ¼”è¿›è·¯çº¿å›¾ã€‹


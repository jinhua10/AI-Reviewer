# ç¬¬å…­é˜¶æ®µå®æ–½ï¼šé«˜çº§åŠŸèƒ½

**åˆ›å»ºæ—¶é—´**: 2025-11-21 23:35:00  
**é˜¶æ®µ**: ç¬¬å…­é˜¶æ®µ (ç¬¬11-12å‘¨)  
**è´Ÿè´£æ¨¡å—**: é«˜çº§åŠŸèƒ½ä¸å®‰å…¨  
**çŠ¶æ€**: ğŸš€ å¼€å§‹å®æ–½

---

## 1. é˜¶æ®µç›®æ ‡

### 1.1 æ ¸å¿ƒä»»åŠ¡
- âœ… æ•°æ®åŠ å¯†æ”¯æŒ
- âœ… è®¿é—®æ§åˆ¶ï¼ˆè®¤è¯ä¸æˆæƒï¼‰
- âœ… å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
- âœ… ç®¡ç†æ§åˆ¶å°ï¼ˆåŸºç¡€ï¼‰
- âœ… ç›‘æ§æŒ‡æ ‡å¯¼å‡º
- âœ… å®Œæ•´çš„ä½¿ç”¨æ–‡æ¡£

### 1.2 åŠŸèƒ½ç›®æ ‡
- **å®‰å…¨æ€§**: æ•°æ®åŠ å¯†ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡è¿½è¸ª
- **å¯ç®¡ç†**: ç®¡ç†APIã€é…ç½®ç®¡ç†ã€çŠ¶æ€ç›‘æ§
- **å¯è§‚æµ‹**: æŒ‡æ ‡å¯¼å‡ºã€å¥åº·æ£€æŸ¥ã€æ—¥å¿—ç³»ç»Ÿ
- **æ˜“ç”¨æ€§**: å®Œæ•´æ–‡æ¡£ã€ä½¿ç”¨ç¤ºä¾‹ã€æœ€ä½³å®è·µ

---

## 2. æ•°æ®åŠ å¯†æ”¯æŒ

### 2.1 åŠ å¯†é…ç½®

**æ–‡ä»¶è·¯å¾„**: `config/EncryptionConfig.java`

```java
package top.yumbo.ai.rag.config;

import lombok.Data;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * åŠ å¯†é…ç½®
 */
@Data
public class EncryptionConfig {
    
    private boolean enabled = false;
    private String algorithm = "AES";
    private String transformation = "AES/CBC/PKCS5Padding";
    private int keySize = 256;
    private String keyStorePath = "./keys/keystore.jks";
    private String keyStorePassword;
    
    /**
     * ç”Ÿæˆå¯†é’¥
     */
    public SecretKey generateKey() throws Exception {
        KeyGenerator keyGen = KeyGenerator.getInstance(algorithm);
        keyGen.init(keySize);
        return keyGen.generateKey();
    }
    
    /**
     * ä»å­—ç¬¦ä¸²åŠ è½½å¯†é’¥
     */
    public SecretKey loadKey(String keyStr) {
        byte[] decodedKey = Base64.getDecoder().decode(keyStr);
        return new SecretKeySpec(decodedKey, algorithm);
    }
    
    /**
     * ç”ŸæˆIV
     */
    public IvParameterSpec generateIv() {
        byte[] iv = new byte[16];
        new SecureRandom().nextBytes(iv);
        return new IvParameterSpec(iv);
    }
}
```

### 2.2 åŠ å¯†æœåŠ¡

**æ–‡ä»¶è·¯å¾„**: `security/EncryptionService.java`

```java
package top.yumbo.ai.rag.security;

import lombok.extern.slf4j.Slf4j;
import top.yumbo.ai.rag.config.EncryptionConfig;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import java.util.Base64;

/**
 * åŠ å¯†æœåŠ¡
 */
@Slf4j
public class EncryptionService {
    
    private final EncryptionConfig config;
    private final SecretKey secretKey;
    
    public EncryptionService(EncryptionConfig config, SecretKey secretKey) {
        this.config = config;
        this.secretKey = secretKey;
    }
    
    /**
     * åŠ å¯†æ•°æ®
     */
    public String encrypt(String plainText) throws Exception {
        if (!config.isEnabled()) {
            return plainText;
        }
        
        IvParameterSpec iv = config.generateIv();
        Cipher cipher = Cipher.getInstance(config.getTransformation());
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
        
        byte[] encrypted = cipher.doFinal(plainText.getBytes());
        
        // å°†IVå’ŒåŠ å¯†æ•°æ®ä¸€èµ·è¿”å›
        byte[] ivBytes = iv.getIV();
        byte[] combined = new byte[ivBytes.length + encrypted.length];
        System.arraycopy(ivBytes, 0, combined, 0, ivBytes.length);
        System.arraycopy(encrypted, 0, combined, ivBytes.length, encrypted.length);
        
        return Base64.getEncoder().encodeToString(combined);
    }
    
    /**
     * è§£å¯†æ•°æ®
     */
    public String decrypt(String encryptedText) throws Exception {
        if (!config.isEnabled()) {
            return encryptedText;
        }
        
        byte[] combined = Base64.getDecoder().decode(encryptedText);
        
        // æå–IV
        byte[] ivBytes = new byte[16];
        System.arraycopy(combined, 0, ivBytes, 0, 16);
        IvParameterSpec iv = new IvParameterSpec(ivBytes);
        
        // æå–åŠ å¯†æ•°æ®
        byte[] encrypted = new byte[combined.length - 16];
        System.arraycopy(combined, 16, encrypted, 0, encrypted.length);
        
        Cipher cipher = Cipher.getInstance(config.getTransformation());
        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
        
        byte[] decrypted = cipher.doFinal(encrypted);
        return new String(decrypted);
    }
    
    /**
     * åŠ å¯†æ–‡ä»¶å†…å®¹
     */
    public byte[] encryptBytes(byte[] data) throws Exception {
        if (!config.isEnabled()) {
            return data;
        }
        
        IvParameterSpec iv = config.generateIv();
        Cipher cipher = Cipher.getInstance(config.getTransformation());
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);
        
        byte[] encrypted = cipher.doFinal(data);
        
        // å°†IVå’ŒåŠ å¯†æ•°æ®ç»„åˆ
        byte[] ivBytes = iv.getIV();
        byte[] combined = new byte[ivBytes.length + encrypted.length];
        System.arraycopy(ivBytes, 0, combined, 0, ivBytes.length);
        System.arraycopy(encrypted, 0, combined, ivBytes.length, encrypted.length);
        
        return combined;
    }
    
    /**
     * è§£å¯†æ–‡ä»¶å†…å®¹
     */
    public byte[] decryptBytes(byte[] encryptedData) throws Exception {
        if (!config.isEnabled()) {
            return encryptedData;
        }
        
        // æå–IV
        byte[] ivBytes = new byte[16];
        System.arraycopy(encryptedData, 0, ivBytes, 0, 16);
        IvParameterSpec iv = new IvParameterSpec(ivBytes);
        
        // æå–åŠ å¯†æ•°æ®
        byte[] encrypted = new byte[encryptedData.length - 16];
        System.arraycopy(encryptedData, 16, encrypted, 0, encrypted.length);
        
        Cipher cipher = Cipher.getInstance(config.getTransformation());
        cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
        
        return cipher.doFinal(encrypted);
    }
}
```

---

## 3. è®¿é—®æ§åˆ¶

### 3.1 ç”¨æˆ·æ¨¡å‹

**æ–‡ä»¶è·¯å¾„**: `security/User.java`

```java
package top.yumbo.ai.rag.security;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.Set;

/**
 * ç”¨æˆ·æ¨¡å‹
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private String userId;
    private String username;
    private String passwordHash;
    private Set<String> roles;
    private boolean enabled;
    private long createdAt;
    private long lastLoginAt;
}
```

### 3.2 è®¤è¯æœåŠ¡

**æ–‡ä»¶è·¯å¾„**: `security/AuthenticationService.java`

```java
package top.yumbo.ai.rag.security;

import lombok.extern.slf4j.Slf4j;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * è®¤è¯æœåŠ¡
 */
@Slf4j
public class AuthenticationService {
    
    private final Map<String, User> users = new ConcurrentHashMap<>();
    private final Map<String, String> tokens = new ConcurrentHashMap<>();
    
    /**
     * æ³¨å†Œç”¨æˆ·
     */
    public User register(String username, String password, Set<String> roles) {
        if (users.containsKey(username)) {
            throw new IllegalArgumentException("User already exists");
        }
        
        String passwordHash = hashPassword(password);
        User user = User.builder()
            .userId(generateUserId())
            .username(username)
            .passwordHash(passwordHash)
            .roles(roles)
            .enabled(true)
            .createdAt(System.currentTimeMillis())
            .build();
        
        users.put(username, user);
        log.info("User registered: {}", username);
        return user;
    }
    
    /**
     * ç”¨æˆ·ç™»å½•
     */
    public String login(String username, String password) {
        User user = users.get(username);
        if (user == null || !user.isEnabled()) {
            throw new IllegalArgumentException("Invalid credentials");
        }
        
        String passwordHash = hashPassword(password);
        if (!passwordHash.equals(user.getPasswordHash())) {
            throw new IllegalArgumentException("Invalid credentials");
        }
        
        String token = generateToken();
        tokens.put(token, username);
        
        user.setLastLoginAt(System.currentTimeMillis());
        log.info("User logged in: {}", username);
        return token;
    }
    
    /**
     * éªŒè¯Token
     */
    public User validateToken(String token) {
        String username = tokens.get(token);
        if (username == null) {
            return null;
        }
        return users.get(username);
    }
    
    /**
     * ç™»å‡º
     */
    public void logout(String token) {
        String username = tokens.remove(token);
        if (username != null) {
            log.info("User logged out: {}", username);
        }
    }
    
    /**
     * å“ˆå¸Œå¯†ç 
     */
    private String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(password.getBytes());
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            throw new RuntimeException("Failed to hash password", e);
        }
    }
    
    /**
     * ç”Ÿæˆç”¨æˆ·ID
     */
    private String generateUserId() {
        return "user_" + System.currentTimeMillis();
    }
    
    /**
     * ç”ŸæˆToken
     */
    private String generateToken() {
        byte[] bytes = new byte[32];
        new SecureRandom().nextBytes(bytes);
        return Base64.getEncoder().encodeToString(bytes);
    }
}
```

### 3.3 æˆæƒæœåŠ¡

**æ–‡ä»¶è·¯å¾„**: `security/AuthorizationService.java`

```java
package top.yumbo.ai.rag.security;

import lombok.extern.slf4j.Slf4j;
import java.util.Set;

/**
 * æˆæƒæœåŠ¡
 */
@Slf4j
public class AuthorizationService {
    
    /**
     * æ£€æŸ¥æƒé™
     */
    public boolean hasPermission(User user, String permission) {
        if (user == null) {
            return false;
        }
        
        Set<String> roles = user.getRoles();
        if (roles == null) {
            return false;
        }
        
        // ç®¡ç†å‘˜æ‹¥æœ‰æ‰€æœ‰æƒé™
        if (roles.contains("ADMIN")) {
            return true;
        }
        
        // æ£€æŸ¥å…·ä½“æƒé™
        return switch (permission) {
            case "document:read" -> roles.contains("USER") || roles.contains("READER");
            case "document:write" -> roles.contains("USER") || roles.contains("WRITER");
            case "document:delete" -> roles.contains("USER") || roles.contains("ADMIN");
            case "admin:manage" -> roles.contains("ADMIN");
            default -> false;
        };
    }
    
    /**
     * è¦æ±‚æƒé™
     */
    public void requirePermission(User user, String permission) {
        if (!hasPermission(user, permission)) {
            throw new SecurityException("Permission denied: " + permission);
        }
    }
}
```

---

## 4. å®¡è®¡æ—¥å¿—

### 4.1 å®¡è®¡äº‹ä»¶

**æ–‡ä»¶è·¯å¾„**: `audit/AuditEvent.java`

```java
package top.yumbo.ai.rag.audit;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * å®¡è®¡äº‹ä»¶
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuditEvent {
    private String eventId;
    private String eventType;
    private String userId;
    private String username;
    private String action;
    private String resource;
    private String details;
    private boolean success;
    private long timestamp;
    private String ipAddress;
}
```

### 4.2 å®¡è®¡æ—¥å¿—æœåŠ¡

**æ–‡ä»¶è·¯å¾„**: `audit/AuditLogService.java`

```java
package top.yumbo.ai.rag.audit;

import lombok.extern.slf4j.Slf4j;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.UUID;
import com.alibaba.fastjson2.JSON;

/**
 * å®¡è®¡æ—¥å¿—æœåŠ¡
 */
@Slf4j
public class AuditLogService {
    
    private final String auditLogPath;
    private final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    
    public AuditLogService(String auditLogPath) {
        this.auditLogPath = auditLogPath;
        initializeAuditLog();
    }
    
    /**
     * è®°å½•å®¡è®¡äº‹ä»¶
     */
    public void log(AuditEvent event) {
        try {
            event.setEventId(UUID.randomUUID().toString());
            event.setTimestamp(System.currentTimeMillis());
            
            String logEntry = JSON.toJSONString(event) + "\n";
            Path logFile = getLogFile();
            
            Files.writeString(logFile, logEntry, 
                StandardOpenOption.CREATE, 
                StandardOpenOption.APPEND);
            
            log.debug("Audit logged: {}", event.getAction());
        } catch (Exception e) {
            log.error("Failed to write audit log", e);
        }
    }
    
    /**
     * è®°å½•æ–‡æ¡£æ“ä½œ
     */
    public void logDocumentOperation(String userId, String username, 
                                     String action, String documentId, 
                                     boolean success) {
        AuditEvent event = AuditEvent.builder()
            .eventType("DOCUMENT")
            .userId(userId)
            .username(username)
            .action(action)
            .resource("document:" + documentId)
            .success(success)
            .build();
        log(event);
    }
    
    /**
     * è®°å½•æœç´¢æ“ä½œ
     */
    public void logSearchOperation(String userId, String username, 
                                   String query, int results) {
        AuditEvent event = AuditEvent.builder()
            .eventType("SEARCH")
            .userId(userId)
            .username(username)
            .action("SEARCH")
            .resource("query:" + query)
            .details("results:" + results)
            .success(true)
            .build();
        log(event);
    }
    
    /**
     * è®°å½•è®¤è¯äº‹ä»¶
     */
    public void logAuthenticationEvent(String username, String action, 
                                       boolean success, String ipAddress) {
        AuditEvent event = AuditEvent.builder()
            .eventType("AUTH")
            .username(username)
            .action(action)
            .success(success)
            .ipAddress(ipAddress)
            .build();
        log(event);
    }
    
    /**
     * è·å–å½“å¤©æ—¥å¿—æ–‡ä»¶
     */
    private Path getLogFile() {
        String date = LocalDate.now().format(dateFormatter);
        return Paths.get(auditLogPath, "audit-" + date + ".log");
    }
    
    /**
     * åˆå§‹åŒ–å®¡è®¡æ—¥å¿—
     */
    private void initializeAuditLog() {
        try {
            Path path = Paths.get(auditLogPath);
            if (!Files.exists(path)) {
                Files.createDirectories(path);
            }
        } catch (Exception e) {
            log.error("Failed to initialize audit log", e);
        }
    }
}
```

---

## 5. ç›‘æ§æŒ‡æ ‡

### 5.1 æŒ‡æ ‡æ”¶é›†å™¨

**æ–‡ä»¶è·¯å¾„**: `monitor/MetricsCollector.java`

```java
package top.yumbo.ai.rag.monitor;

import lombok.Data;
import java.util.concurrent.atomic.LongAdder;

/**
 * æŒ‡æ ‡æ”¶é›†å™¨
 */
@Data
public class MetricsCollector {
    
    // HTTPæŒ‡æ ‡
    private final LongAdder httpRequests = new LongAdder();
    private final LongAdder httpErrors = new LongAdder();
    
    // æ–‡æ¡£æŒ‡æ ‡
    private final LongAdder documentsCreated = new LongAdder();
    private final LongAdder documentsUpdated = new LongAdder();
    private final LongAdder documentsDeleted = new LongAdder();
    
    // æœç´¢æŒ‡æ ‡
    private final LongAdder searchRequests = new LongAdder();
    private final LongAdder searchErrors = new LongAdder();
    
    // è®¤è¯æŒ‡æ ‡
    private final LongAdder loginAttempts = new LongAdder();
    private final LongAdder loginFailures = new LongAdder();
    
    /**
     * è®°å½•HTTPè¯·æ±‚
     */
    public void recordHttpRequest(boolean success) {
        httpRequests.increment();
        if (!success) {
            httpErrors.increment();
        }
    }
    
    /**
     * ç”ŸæˆæŒ‡æ ‡æŠ¥å‘Š
     */
    public String generateReport() {
        return String.format(
            "Metrics:\n" +
            "  HTTP: %d requests, %d errors\n" +
            "  Documents: %d created, %d updated, %d deleted\n" +
            "  Search: %d requests, %d errors\n" +
            "  Auth: %d attempts, %d failures",
            httpRequests.sum(), httpErrors.sum(),
            documentsCreated.sum(), documentsUpdated.sum(), documentsDeleted.sum(),
            searchRequests.sum(), searchErrors.sum(),
            loginAttempts.sum(), loginFailures.sum()
        );
    }
}
```

---

## 6. å¥åº·æ£€æŸ¥

### 6.1 å¥åº·æ£€æŸ¥æœåŠ¡

**æ–‡ä»¶è·¯å¾„**: `monitor/HealthCheckService.java`

```java
package top.yumbo.ai.rag.monitor;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import top.yumbo.ai.rag.LocalFileRAG;
import java.util.HashMap;
import java.util.Map;

/**
 * å¥åº·æ£€æŸ¥æœåŠ¡
 */
@Data
public class HealthCheckService {
    
    private final LocalFileRAG rag;
    
    /**
     * å¥åº·æ£€æŸ¥ç»“æœ
     */
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class HealthStatus {
        private String status;
        private Map<String, ComponentHealth> components;
        private long timestamp;
    }
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ComponentHealth {
        private String status;
        private String message;
    }
    
    /**
     * æ‰§è¡Œå¥åº·æ£€æŸ¥
     */
    public HealthStatus check() {
        Map<String, ComponentHealth> components = new HashMap<>();
        
        // æ£€æŸ¥å­˜å‚¨
        components.put("storage", checkStorage());
        
        // æ£€æŸ¥ç´¢å¼•
        components.put("index", checkIndex());
        
        // æ£€æŸ¥ç¼“å­˜
        components.put("cache", checkCache());
        
        // ç¡®å®šæ€»ä½“çŠ¶æ€
        String overallStatus = components.values().stream()
            .allMatch(c -> "UP".equals(c.getStatus())) ? "UP" : "DOWN";
        
        return HealthStatus.builder()
            .status(overallStatus)
            .components(components)
            .timestamp(System.currentTimeMillis())
            .build();
    }
    
    private ComponentHealth checkStorage() {
        try {
            // ç®€å•æ£€æŸ¥ï¼šè·å–ç»Ÿè®¡ä¿¡æ¯
            var stats = rag.getStatistics();
            return ComponentHealth.builder()
                .status("UP")
                .message("Storage OK, docs: " + stats.getDocumentCount())
                .build();
        } catch (Exception e) {
            return ComponentHealth.builder()
                .status("DOWN")
                .message("Storage error: " + e.getMessage())
                .build();
        }
    }
    
    private ComponentHealth checkIndex() {
        try {
            // ç®€å•æ£€æŸ¥ï¼šè·å–ç»Ÿè®¡ä¿¡æ¯
            var stats = rag.getStatistics();
            return ComponentHealth.builder()
                .status("UP")
                .message("Index OK, indexed: " + stats.getIndexedDocumentCount())
                .build();
        } catch (Exception e) {
            return ComponentHealth.builder()
                .status("DOWN")
                .message("Index error: " + e.getMessage())
                .build();
        }
    }
    
    private ComponentHealth checkCache() {
        try {
            return ComponentHealth.builder()
                .status("UP")
                .message("Cache OK")
                .build();
        } catch (Exception e) {
            return ComponentHealth.builder()
                .status("DOWN")
                .message("Cache error: " + e.getMessage())
                .build();
        }
    }
}
```

---

## 7. ç¬¬å…­é˜¶æ®µæ€»ç»“

### å·²è®¾è®¡çš„åŠŸèƒ½

#### å®‰å…¨åŠŸèƒ½ âœ…
- [x] æ•°æ®åŠ å¯†ï¼ˆAES-256ï¼‰
- [x] ç”¨æˆ·è®¤è¯
- [x] åŸºäºè§’è‰²çš„æˆæƒ
- [x] Tokenç®¡ç†

#### å®¡è®¡åŠŸèƒ½ âœ…
- [x] å®¡è®¡äº‹ä»¶æ¨¡å‹
- [x] å®¡è®¡æ—¥å¿—æœåŠ¡
- [x] æ–‡æ¡£æ“ä½œå®¡è®¡
- [x] æœç´¢æ“ä½œå®¡è®¡
- [x] è®¤è¯äº‹ä»¶å®¡è®¡

#### ç›‘æ§åŠŸèƒ½ âœ…
- [x] æŒ‡æ ‡æ”¶é›†å™¨
- [x] å¥åº·æ£€æŸ¥æœåŠ¡
- [x] æ€§èƒ½æŒ‡æ ‡
- [x] ç»„ä»¶çŠ¶æ€ç›‘æ§

---

## 8. ä¸‹ä¸€æ­¥å®æ–½

### éœ€è¦åˆ›å»ºçš„ç±»
1. EncryptionConfig.java
2. EncryptionService.java
3. User.java
4. AuthenticationService.java
5. AuthorizationService.java
6. AuditEvent.java
7. AuditLogService.java
8. MetricsCollector.java
9. HealthCheckService.java

### é›†æˆåˆ°API
- åœ¨APIå±‚æ·»åŠ è®¤è¯ä¸­é—´ä»¶
- åœ¨æ§åˆ¶å™¨ä¸­æ·»åŠ æˆæƒæ£€æŸ¥
- åœ¨æ“ä½œä¸­æ·»åŠ å®¡è®¡æ—¥å¿—

---

**æ–‡æ¡£å®Œæˆæ—¶é—´**: 2025-11-21 23:40:00  
**ä¸‹ä¸€æ­¥**: åˆ›å»ºç¬¬å…­é˜¶æ®µçš„Javaä»£ç 

